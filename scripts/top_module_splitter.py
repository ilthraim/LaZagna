# Script to parse a fpga_top.v generated by 3D FADE and split it into multiple files where each file is a layer
# with a top module instatiating the layers

import os
import re
import sys
import argparse
import fileinput

#key is signal name, value is layer
interlayer_signals = {}

layer_0_inputs = set()
layer_1_inputs = set()

layer_0_outputs = set()
layer_1_outputs = set()

def add_line_to_layer_file(layer_num, line):
    layer_file = os.path.join(output_dir, f'layer_{layer_num}.v')
    if not os.path.exists(layer_file):
        with open(layer_file, 'w') as f:
            f.write(line)
    else:
        with open(layer_file, 'a') as f:
            f.write(line)

def add_input_to_layer_file(layer_num, line):
    layer_file = os.path.join(output_dir, f'layer_{layer_num}.v')
    if not os.path.exists(layer_file):
        with open(layer_file, 'w') as f:
            f.write(line.replace('wire', 'input') + "\n")
    else:
        with open(layer_file, 'a') as f:
            f.write(line.replace('wire', 'input') + "\n")

def add_output_to_layer_file(layer_num, line):
    layer_file = os.path.join(output_dir, f'layer_{layer_num}.v')
    if not os.path.exists(layer_file):
        with open(layer_file, 'w') as f:
            f.write(line.replace('wire', 'output') + "\n")
    else:
        with open(layer_file, 'a') as f:
            f.write(line.replace('wire', 'output') + "\n")

def add_line_to_top_file(line):
    top_file = os.path.join(output_dir, 'fpga_top_new.v')
    if not os.path.exists(top_file):
        with open(top_file, 'w') as f:
            f.write(line)
    else:
        with open(top_file, 'a') as f:
            f.write(line)

def load_module_instantiation(layer_num):
    file_path = os.path.join(output_dir, f'layer_{layer_num}.v')
    output = ''
    with open(file_path, 'r') as f:
        file_lines = f.readlines()

    hit_module=False

    for line in file_lines:
        if line.startswith('module '):
            output += line.replace(f"module layer_{layer_num}", '')
            hit_module=True

        elif hit_module:
            if ");" not in line:
                output += line
            else:
                output += line
                break

    return output

signal_name_from_wire_declare = re.compile(r'wire\s+\[.*\]?\s+(\w+);')

def add_end_module_to_layer_file(layer_num):
    layer_file = os.path.join(output_dir, f'layer_{layer_num}.v')
    with open(layer_file, 'a') as f:
        f.write('endmodule\n')

def add_end_module_to_top_file():
    top_file = os.path.join(output_dir, 'fpga_top_new.v')
    with open(top_file, 'a') as f:
        f.write('endmodule\n')

def add_new_signals_to_layer_modules(layer_num, new_signals):
    layer_file = os.path.join(output_dir, f'layer_{layer_num}.v')
    with open(layer_file, 'r') as f:
        file_lines = f.readlines()

    for line in file_lines:
        if top_module_end_regex.match(line):
            line_arr = line.split(')')
            first_line = line_arr[0]
            first_line += ',\n\t\t'
            for new_signal in new_signals:
                first_line += new_signal
                first_line += ',\n\t\t'
            # remove last extra comma
            first_line = first_line[:-1]

            first_line += ');\n\n'

            replaceAll(layer_file, line, first_line)

            break

def is_interlayer_wire(line):
    signal_name_match = signal_name_from_wire_declare.match(line)
    # print(f"Checking if {line} is an interlayer wire")
    if signal_name_match:
        signal_name = signal_name_match.group(1)
        # print(f"Checking if {signal_name} is an interlayer wire")
        if signal_name in interlayer_signals.keys():
            return True, interlayer_signals[signal_name]
    
    return False, -1


wire_regex = re.compile(r'wire\s+\[.*\]?\s*.*_(\d+)_\d+_\d+.*;')
grid_wire_regex = re.compile(r'wire\s\[\d+[^]]\d+]\s(\w+);')

parser = argparse.ArgumentParser(description='Split a fpga_top.v file into multiple files where each file is a layer')
parser.add_argument('-f','-fpga_top', help='Path to the fpga_top.v file', required=True)
parser.add_argument('-o','-output', help='Path to the output directory. Defaults to location where this script is run', default='.')

args = parser.parse_args()
fpga_top_path = args.f
output_dir = args.o

if not os.path.exists(fpga_top_path):
    print(f'Error: {fpga_top_path} does not exist')
    sys.exit(1)

# Read the fpga_top file
with open(fpga_top_path, 'r') as f:
    top_file_lines = f.readlines()

#create fresh files
for i in range(2):
    layer_file = os.path.join(output_dir, f'layer_{i}.v')
    if os.path.exists(layer_file):
        os.remove(layer_file)

top_file = os.path.join(output_dir, 'fpga_top_new.v')
if os.path.exists(top_file):
    os.remove(top_file)

# create a module to location dictionary key: signal name, value: layer
module_location_dict = {}

module_start_regex = re.compile(r'\s+(\w+)\s+\w+_(\d+)_(\d+)_(\d+)_.+\s*\(')

module_end_regex = re.compile(r'\s+\.\w+\(\w+(?:\[\d+:\d+\])?\)\);')

module_signal_with_location_regex = re.compile(r'\s*\.\w+\(\w+_(\d+)_(\d+)_(\d+)_\w+(?:\[\d+:\d+\])?\),')

module_signal_regex = re.compile(r'\s*\.\w+\((.+)\)')

for i in range(len(top_file_lines)):
    line = top_file_lines[i]
    module_match = module_start_regex.match(line)
    if module_match:
        module_name = module_match.group(1)

        # print(f'Found module {module_name}')


        module_layer = int(module_match.group(2))
        module_location = (int(module_match.group(3)), int(module_match.group(4)))


        module_end_match = module_end_regex.match(top_file_lines[i+1])
        
        while not module_end_match:
            i += 1
            module_end_match = module_end_regex.match(top_file_lines[i])

            # regex to match the signal belonging to the module
            module_signal_with_index_regex = re.compile(rf'{module_name}_(\w+)_[a-zA-Z]+_\w+(?:\[\d+:\d+\])?')

            module_signal = module_signal_regex.match(top_file_lines[i])
            if module_signal:



                module_signal_with_location = module_signal_with_location_regex.match(top_file_lines[i])

                signal_name = module_signal.group(1)

                # My regex is off but idk how to fix it so this is a hacky workaround
                signal_name = signal_name.replace(')', '')    


                # Determine if a signal is interlayer
                if module_signal_with_location:
                    
                    signal_layer = int(module_signal_with_location.group(1))
                    
                    if signal_layer != module_layer:
                        # replace [\d+:\d+] with ''
                        signal_name = re.sub(r'\[\d+:\d+\]', '', signal_name)

                        interlayer_signals[signal_name] = signal_layer
                
                #Determine if the module
                module_signal_with_index = module_signal_with_index_regex.match(signal_name)

                if signal_name in module_location_dict.keys():
                    if module_name not in signal_name:
                        if module_location_dict[signal_name] != module_layer:

                            # need to check if there is overlap between module name and signal name
                            interlayer_signals[signal_name] = module_location_dict[signal_name]

                if module_name in signal_name:
                    module_location_dict[signal_name] = module_layer

    i+=1

# Copy top of 'fpga_top.v' file to 'fpga_top_new.v'
for line in top_file_lines:
    if 'BEGIN wire-connection ports' in line:
        break
    add_line_to_top_file(line)

    if 'fpga_top' in line:
        line = line.replace('fpga_top', 'layer_0')
    add_line_to_layer_file(0, line)

    if 'layer_0' in line:
        line = line.replace('layer_0', 'layer_1')
    add_line_to_layer_file(1, line)

add_line_to_top_file(' ')

layer_0_wires = []
layer_1_wires = []

wire_regex_grid = re.compile(r'wire\s+\[.*\]?\s*.*_(\d+)_\w+;')

for line in top_file_lines:
    wire_match_sb_cb = wire_regex.match(line)
    wire_match_grid = wire_regex_grid.match(line)
    if wire_match_sb_cb:
        layer_num = int(wire_match_sb_cb.group(1))
        if layer_num == 0:
            layer_0_wires.append(line)
        elif layer_num == 1:
            layer_1_wires.append(line)

        is_interlayer, signal_layer = is_interlayer_wire(line)

        if (is_interlayer):
            # print(f"{line} is an interlayer wire")
            add_line_to_top_file(line)

            if signal_layer == 1:
                # add_input_to_layer_file(0, line)
                layer_1_wires.remove(line)
                layer_0_inputs.add(line)
                layer_1_outputs.add(line)
            elif signal_layer == 0:
                # add_input_to_layer_file(1, line)
                layer_0_wires.remove(line)
                layer_0_outputs.add(line)
                layer_1_inputs.add(line)
            else:
                print(f"Error: {line} is an interlayer wire but the signal layer is not 0 or 1")
                sys.exit(1)
    elif wire_match_grid:
        
        signal_name = line.split(' ')[-1].replace(';\n', '')
        signal_name = signal_name.replace(')', '')
        signal_layer = module_location_dict[signal_name]

        if signal_layer == 1:
            layer_1_wires.append(line)
        elif signal_layer == 0:
            layer_0_wires.append(line)

        is_interlayer, signal_layer = is_interlayer_wire(line)

        if is_interlayer:
            add_line_to_top_file(line)

            if signal_layer == 1:
                layer_1_wires.remove(line)
                layer_0_inputs.add(line)
                layer_1_outputs.add(line)
            elif signal_layer == 0:
                layer_0_wires.remove(line)
                layer_0_outputs.add(line)
                layer_1_inputs.add(line)
module_layer_0_new_signals = set()       
module_layer_1_new_signals = set()

def replaceAll(file,searchExp,replaceExp):
    for line in fileinput.input(file, inplace=1):
        if searchExp in line:
            line = line.replace(searchExp,replaceExp)
        sys.stdout.write(line)

for input_signal in layer_0_inputs:
    input_name = signal_name_from_wire_declare.match(input_signal).group(1)
    module_layer_0_new_signals.add(input_name)
    #Add to module instantiation

for output_signal in layer_0_outputs:
    output_name = signal_name_from_wire_declare.match(output_signal).group(1)
    module_layer_0_new_signals.add(output_name)

for input_signal in layer_1_inputs:
    input_name = signal_name_from_wire_declare.match(input_signal).group(1)
    module_layer_1_new_signals.add(input_name)

for output_signal in layer_1_outputs:
    output_name = signal_name_from_wire_declare.match(output_signal).group(1)
    module_layer_1_new_signals.add(output_name)

top_module_end_regex = re.compile(r'\s+\w+\);')


add_new_signals_to_layer_modules(0, module_layer_0_new_signals) 
add_new_signals_to_layer_modules(1, module_layer_1_new_signals)

for input_signal in layer_0_inputs:
    add_input_to_layer_file(0, input_signal)
    
for input_signal in layer_1_inputs:
    add_input_to_layer_file(1, input_signal)
    
for output_signal in layer_0_outputs:
    add_output_to_layer_file(0, output_signal)

for output_signal in layer_1_outputs:
    add_output_to_layer_file(1, output_signal)

for wire in layer_0_wires:
    if wire not in layer_0_inputs and wire not in layer_0_outputs:
        add_line_to_layer_file(0, wire)

for wire in layer_1_wires:
    if wire not in layer_1_inputs and wire not in layer_1_outputs:
        add_line_to_layer_file(1, wire)

# Copy modules to respective file
for i in range(len(top_file_lines)):
    line = top_file_lines[i]
    module_match = module_start_regex.match(line)

    if module_match:
        module_name = module_match.group(1)
    
        module_layer = int(module_match.group(2))
        module_location = (int(module_match.group(3)), int(module_match.group(4)))

        module_end_match = module_end_regex.match(top_file_lines[i+1])

        # print(f'Found module {module_name} at layer {module_layer}')    

        while not module_end_match:
            i += 1
            module_end_match = module_end_regex.match(top_file_lines[i])
            add_line_to_layer_file(module_layer, line)

            line = top_file_lines[i]

        add_line_to_layer_file(module_layer, line)

    i+=1

          
# Instantiate the layers in the top module

layer_0_module_instantiation = load_module_instantiation(0)
layer_1_module_instantiation = load_module_instantiation(1)

add_line_to_top_file("layer_0 layer_0_inst" + layer_0_module_instantiation)
add_line_to_top_file("layer_1 layer_1_inst" + layer_1_module_instantiation)


add_end_module_to_top_file()
add_end_module_to_layer_file(0)
add_end_module_to_layer_file(1)


